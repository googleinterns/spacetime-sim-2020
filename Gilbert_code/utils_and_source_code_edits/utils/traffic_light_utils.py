from lxml import etree
from xml.etree import ElementTree
import random
import matplotlib.pyplot as plt
from flow.core.util import ensure_dir
import os
from flow.core.params import SumoParams, EnvParams, InitialConfig, NetParams
from flow.core.params import InFlows
import numpy as np


def trip_info_emission_to_csv(emission_path, output_path=None):
    """Convert an trip_info file generated by sumo into a csv file.

    Note that the trip_info file contains information generated by sumo, not
    flow.

    Parameters
    ----------
    emission_path : str
        path to the trip_info file that should be converted
    output_path : str
        path to the csv file that will be generated, default is the same
        directory as the trip_info file, with the same name
    """
    parser = etree.XMLParser(recover=True)
    tree = ElementTree.parse(emission_path, parser=parser)
    root = tree.getroot()

    # parse the xml data into a dict
    out_data = []
    for car in root.findall("tripinfo"):
        out_data.append(dict())
        try:
            out_data[-1]['travel_times'] = float(car.attrib['duration'])
            out_data[-1]['arrival'] = float(car.attrib['arrival'])
            out_data[-1]['id'] = car.attrib['id']
        except KeyError:
            del out_data[-1]

    # sort the elements of the dictionary by the vehicle id
    out_data = sorted(out_data, key=lambda k: k['id'])

    # default output path
    if output_path is None:
        output_path = emission_path[:-3] + 'csv'

    # output the dict data into a csv file
    # keys = out_data[0].keys()
    # with open(output_path, 'w') as output_file:
    #     dict_writer = csv.DictWriter(output_file, keys)
    #     dict_writer.writeheader()
    #     dict_writer.writerows(out_data)

    return out_data


def get_truncated_normal(mean=0, sd=1800, low=0, upp=10):
    while True:
        rd = random.normalvariate(mean, sd)
        if rd >= low and rd <= upp:
            return int(rd)


def generate_demands(segment_id_pairs, network_name, horizon, is_uniform, num_of_vehicles, save_hist=True):

    """Generate a xml file of routes.
    format: <vehicle id="0" departLane="?" arrivalLane="?" depart="0"/>
    Args:
      is_uniform: bool, if false then generate a normal distribuiton
      num_of_vehicles: total vehicles in an hour.
      segment_id_pairs: a list of pair of string [(start_segment, end_segment), ...]
        where start_segment and end_segment is the segment id in sumo.
    Returns:
      A string of printable xml route file.
    """
    mean = horizon / 2
    std = 10
    vehicle_str = dict()
    for i in range(num_of_vehicles):
        vehicle_id = "v_%d" % i
        # select one from segemtn_id_pairs as depart & arrival
        route = random.choice(segment_id_pairs)

        if is_uniform:
            time = random.choice(range(0, horizon))
        else:
            # we center demand around horizon/2
            time = get_truncated_normal(mean, std, 0, horizon)

        vehicle_str[time] = dict(name=vehicle_id, vtype="human", route=route, depart=str(time),
                                 departSpeed="5")
    sorted_ids = sorted(vehicle_str.keys())

    # store histogram of demand
    if save_hist:
        home_dir = os.path.expanduser('~')
        ensure_dir('%s' % home_dir + '/ray_results/real_time_metrics/hist')
        hist_path = home_dir + '/ray_results/real_time_metrics/hist/'

        if is_uniform:
            title_flag = "Random Distribution"
        else:
            title_flag = "Peak Distribution: Mean = {} secs, Standard Dev ={} secs,".format(mean, std)

        plt.hist(vehicle_str.keys(), edgecolor='white')
        plt.ylabel("Frequency")
        plt.xlabel("Depart time INTO the Network (secs)")
        plt.title("Demand Data \n {} vehicles \n".format(num_of_vehicles) + title_flag)
        plt.savefig(hist_path + '%s.png' % network_name)
        plt.close()

    return sorted_ids, vehicle_str



def gen_edges(col_num, row_num):
    """Generate the names of the outer edges in the grid network.

    Parameters
    ----------
    col_num : int
        number of columns in the grid
    row_num : int
        number of rows in the grid

    Returns
    -------
    list of str
        names of all the outer edges
    """
    edges_col = []
    edges_row = []

    # build the left and then the right edges
    for i in range(col_num):
        edges_col  += ['left' + str(row_num) + '_' + str(i)]
        edges_col  += ['right' + '0' + '_' + str(i)]

    # build the bottom and then top edges
    for i in range(row_num):
        edges_row += ['bot' + str(i) + '_' + '0']
        edges_row += ['top' + str(i) + '_' + str(col_num)]

    return edges_col, edges_row


def get_flow_params(col_num, row_num, horizon, num_veh_per_row, num_vehcile_per_column, additional_net_params):
    """Define the network and initial params in the presence of inflows.

    Parameters
    ----------
    col_num : int
        number of columns in the grid
    row_num : int
        number of rows in the grid
    additional_net_params : dict
        network-specific parameters that are unique to the grid

    Returns
    -------
    flow.core.params.InitialConfig
        parameters specifying the initial configuration of vehicles in the
        network
    flow.core.params.NetParams
        network-specific parameters used to generate the network
    """
    initial = InitialConfig(
        spacing='custom', lanes_distribution=float('inf'), shuffle=True)

    col_edges, row_edges = gen_edges(col_num, row_num)

    inflow = gen_demand(horizon, num_veh_per_row, num_vehcile_per_column, col_edges, row_edges)

    net = NetParams(
        inflows=inflow,
        additional_params=additional_net_params)

    return initial, net


def gen_demand(horizon,
               num_veh_per_row,
               num_veh_per_column,
               col_edges,
               row_edges,
               is_uniform=True):

    # time = 50
    inflow = InFlows()
    rows = row_edges
    col = col_edges
    mean = horizon / 2
    std = 10
    # vehicle_str = dict()
    row_time = []
    row_edges = []
    col_time = []
    col_edges = []

    # for each row
    for _ in np.arange(num_veh_per_row):
        # pick time
        if is_uniform:
            row_time += [random.choice(range(1, horizon))]
        else:
            # we center demand around horizon/2
            row_time += [get_truncated_normal(mean, std, 1, horizon)]

        # pick edge randomly
        row_edges += [random.choice(rows)]

        # for each column
    for i in np.arange(num_veh_per_column):
        # pick time
        if is_uniform:
            col_time += [random.choice(range(1, horizon))]
        else:
            # we center demand around horizon/2
            col_time += [get_truncated_normal(mean, std, 1, horizon)]

        # pick edge randomly
        col_edges += [random.choice(col)]

    # merge lists
    merged_times = row_time + col_time
    merged_edges = row_edges + col_edges

    sorted_times_and_edges = sorted(zip(merged_times, merged_edges), key=lambda x: x[0])

    # add inflow
    for time, edge in sorted_times_and_edges:
        inflow.add(
            veh_type='human',
            edge=edge,
            probability=1,
            depart_lane='free',
            depart_speed=5,
            begin=time,
            number=1)


    return inflow


def get_truncated_normal(mean=0, sd=1800, low=0, upp=10):
    while True:
        rd = random.normalvariate(mean, sd)
        if rd >= low and rd <= upp:
            return int(rd)


def get_non_flow_params(enter_speed, add_net_params):
    """Define the network and initial params in the absence of inflows.

    Note that when a vehicle leaves a network in this case, it is immediately
    returns to the start of the row/column it was traversing, and in the same
    direction as it was before.

    Parameters
    ----------
    enter_speed : float
        initial speed of vehicles as they enter the network.
    add_net_params: dict
        additional network-specific parameters (unique to the grid)

    Returns
    -------
    flow.core.params.InitialConfig
        parameters specifying the initial configuration of vehicles in the
        network
    flow.core.params.NetParams
        network-specific parameters used to generate the network
    """
    additional_init_params = {'enter_speed': enter_speed}
    initial = InitialConfig(
        spacing='custom', additional_params=additional_init_params)
    net = NetParams(additional_params=add_net_params)

    return initial, net

